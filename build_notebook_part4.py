#!/usr/bin/env python3
"""
Build Part 4: The Silver Gauge - THE REVELATION
This is the climax of the notebook!
"""

import json

def create_part4_cells():
    """Part 4: Silver Gauge - Geometric Fingerprinting (THE CLIMAX!)"""
    cells = []

    # Part 4 Header
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "---\n",
            "\n",
            "# PART 4: The Silver Gauge - Geometric Fingerprinting\n",
            "\n",
            "**Time**: 25 minutes\n",
            "\n",
            "**Goals**:\n",
            "- Understand Pythagorean means (HM, GM, AM)\n",
            "- Create dimensionless k coefficients\n",
            "- Apply to our skills\n",
            "- **DISCOVER**: Why k ‚âà 0 for ALL crisp skills!\n",
            "- Reveal the geometric gap\n",
            "\n",
            "‚≠ê **This is the climax** - the big revelation!"
        ]
    })

    # 4.1 The Diagnostic Challenge
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.1 The Interpretability Challenge"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### ü§î The Problem with EFE\n",
            "\n",
            "We've built an active inference agent that:\n",
            "- ‚úÖ Balances exploration and exploitation\n",
            "- ‚úÖ Updates beliefs using observations\n",
            "- ‚úÖ Chooses optimal skills\n",
            "\n",
            "**But**: Can we UNDERSTAND its strategy at a glance?\n",
            "\n",
            "**Challenge**: Create interpretable metrics WITHOUT changing behavior\n",
            "- Requirement: 100% behavioral fidelity (no approximation)\n",
            "- Goal: Geometric \\\"fingerprint\\\" of decision-making style\n",
            "- Must be: Scale-invariant, dimensionless, bounded\n",
            "\n",
            "**Enter**: The Silver Gauge\n",
            "\n",
            "### üí° Core Idea\n",
            "\n",
            "Instead of just calculating EFE, let's create \\\"shape coefficients\\\" that reveal:\n",
            "- How balanced is this skill? (specialist vs generalist)\n",
            "- How efficient is this skill? (benefit vs cost)\n",
            "\n",
            "**Method**: Pythagorean means (from ~500 BCE!)\n",
            "\"\"\"))"
        ]
    })

    # 4.2 Pythagorean Means
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.2 Pythagorean Means: 2500-Year-Old Math"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(r\"\"\"\n",
            "### üìê Three Classical Means\n",
            "\n",
            "Given two positive numbers $a$ and $b$, the ancient Greeks defined three averages:\n",
            "\n",
            "#### 1. Harmonic Mean (HM) - The Bottleneck Penalizer\n",
            "\n",
            "$$HM = \\frac{2ab}{a + b}$$\n",
            "\n",
            "- Severely penalizes imbalance\n",
            "- If either $a$ or $b$ is small, HM is small\n",
            "- Used for: rates, speeds, efficiency ratios\n",
            "- Example: Average speed for round trip\n",
            "\n",
            "#### 2. Geometric Mean (GM) - The Balanced Multiplier\n",
            "\n",
            "$$GM = \\sqrt{ab}$$\n",
            "\n",
            "- Respects proportional relationships\n",
            "- Balanced compromise between values\n",
            "- Used for: growth rates, aspect ratios\n",
            "- Example: Average percentage growth\n",
            "\n",
            "#### 3. Arithmetic Mean (AM) - The Fair Splitter\n",
            "\n",
            "$$AM = \\frac{a + b}{2}$$\n",
            "\n",
            "- Simple average (what you learned in school)\n",
            "- Fair split of sum\n",
            "- Used for: central tendency\n",
            "- Example: Average height\n",
            "\n",
            "---\n",
            "\n",
            "### üéì The Pythagorean Inequality\n",
            "\n",
            "**Always true**: $HM \\leq GM \\leq AM$\n",
            "\n",
            "**Equality only when**: $a = b$ (perfect balance)\n",
            "\n",
            "Let's explore this interactively!\n",
            "\"\"\"))"
        ]
    })

    # Interactive Pythagorean means calculator
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.3 Interactive: Explore Pythagorean Means"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### üßÆ Pythagorean Means Calculator\n",
            "\n",
            "Try different values and watch the means!\n",
            "\"\"\"))\n",
            "\n",
            "a_slider = widgets.FloatSlider(value=2, min=0.1, max=10, step=0.1, description='a:')\n",
            "b_slider = widgets.FloatSlider(value=8, min=0.1, max=10, step=0.1, description='b:')\n",
            "\n",
            "means_output = widgets.Output()\n",
            "\n",
            "def calculate_means(change):\n",
            "    a = a_slider.value\n",
            "    b = b_slider.value\n",
            "    \n",
            "    with means_output:\n",
            "        clear_output(wait=True)\n",
            "        \n",
            "        # Calculate means\n",
            "        hm = (2 * a * b) / (a + b)\n",
            "        gm = np.sqrt(a * b)\n",
            "        am = (a + b) / 2\n",
            "        \n",
            "        # Balance ratio\n",
            "        k = gm / am\n",
            "        \n",
            "        # Visualize\n",
            "        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n",
            "        \n",
            "        # Left: Bar chart of means\n",
            "        means_values = [hm, gm, am]\n",
            "        means_names = ['HM\\n(bottleneck)', 'GM\\n(balanced)', 'AM\\n(fair split)']\n",
            "        colors_means = ['#e74c3c', '#f39c12', '#3498db']\n",
            "        \n",
            "        bars = ax1.bar(means_names, means_values, color=colors_means, \n",
            "                      alpha=0.7, edgecolor='black', linewidth=2)\n",
            "        ax1.set_ylabel('Value', fontsize=12)\n",
            "        ax1.set_title(f'Pythagorean Means for a={a:.1f}, b={b:.1f}', \n",
            "                     fontsize=14, fontweight='bold')\n",
            "        ax1.grid(axis='y', alpha=0.3)\n",
            "        \n",
            "        # Add value labels\n",
            "        for bar, val in zip(bars, means_values):\n",
            "            height = bar.get_height()\n",
            "            ax1.text(bar.get_x() + bar.get_width()/2., height,\n",
            "                    f'{val:.3f}', ha='center', va='bottom', \n",
            "                    fontsize=11, fontweight='bold')\n",
            "        \n",
            "        # Show inequality\n",
            "        ax1.plot([0, 2], [hm, am], 'k--', alpha=0.3, linewidth=2)\n",
            "        ax1.text(1, (hm + am)/2, f'HM ‚â§ GM ‚â§ AM', \n",
            "                ha='center', fontsize=10, style='italic',\n",
            "                bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))\n",
            "        \n",
            "        # Right: Input values\n",
            "        ax2.barh(['a', 'b'], [a, b], color=['#2ecc71', '#9b59b6'], \n",
            "                alpha=0.7, edgecolor='black', linewidth=2)\n",
            "        ax2.set_xlabel('Value', fontsize=12)\n",
            "        ax2.set_title('Input Values', fontsize=14, fontweight='bold')\n",
            "        ax2.grid(axis='x', alpha=0.3)\n",
            "        \n",
            "        # Balance indicator\n",
            "        balance_ratio = min(a, b) / max(a, b)\n",
            "        ax2.text(0.5, 0.1, f'Balance: {balance_ratio:.1%}\\n(1.0 = perfect)',\n",
            "                transform=ax2.transAxes, ha='center',\n",
            "                bbox=dict(boxstyle='round', \n",
            "                         facecolor='lightgreen' if balance_ratio > 0.7 else 'lightyellow',\n",
            "                         alpha=0.7))\n",
            "        \n",
            "        plt.tight_layout()\n",
            "        plt.show()\n",
            "        \n",
            "        # Text output\n",
            "        print(\"=\"*70)\n",
            "        print(f\"Input: a={a:.2f}, b={b:.2f}\")\n",
            "        print(\"=\"*70)\n",
            "        print(f\"Harmonic Mean (HM):  {hm:.4f}  ‚Üê Bottleneck penalizer\")\n",
            "        print(f\"Geometric Mean (GM): {gm:.4f}  ‚Üê Balanced multiplier\")\n",
            "        print(f\"Arithmetic Mean (AM):{am:.4f}  ‚Üê Fair splitter\")\n",
            "        print(\"-\"*70)\n",
            "        print(f\"Verification: {hm:.4f} ‚â§ {gm:.4f} ‚â§ {am:.4f}\")\n",
            "        print(f\"Inequality holds: {hm <= gm <= am}\")\n",
            "        print(\"=\"*70)\n",
            "        print(f\"\\nBalance ratio k = GM/AM = {k:.4f}\")\n",
            "        if k > 0.95:\n",
            "            print(\"  ‚Üí Nearly perfect balance! (a ‚âà b)\")\n",
            "        elif k > 0.7:\n",
            "            print(\"  ‚Üí Good balance\")\n",
            "        elif k > 0.5:\n",
            "            print(\"  ‚Üí Moderate imbalance\")\n",
            "        else:\n",
            "            print(\"  ‚Üí Severe imbalance (specialist!)\")\n",
            "\n",
            "a_slider.observe(calculate_means, names='value')\n",
            "b_slider.observe(calculate_means, names='value')\n",
            "\n",
            "display(a_slider, b_slider, means_output)\n",
            "calculate_means(None)  # Initial\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üí° Experiments to Try:\n",
            "\n",
            "1. **Perfect balance**: Set a=5, b=5\n",
            "   - Notice: HM = GM = AM (all equal!)\n",
            "   - k = 1.0\n",
            "\n",
            "2. **Moderate imbalance**: Set a=3, b=7\n",
            "   - Notice: HM < GM < AM (inequality holds)\n",
            "   - k ‚âà 0.93 (still pretty balanced)\n",
            "\n",
            "3. **Severe imbalance**: Set a=0.1, b=10\n",
            "   - Notice: HM is VERY small (bottleneck!)\n",
            "   - k ‚âà 0.20 (specialist!)\n",
            "\n",
            "**Key Insight**: The ratio k = GM/AM measures balance!\n",
            "\"\"\"))"
        ]
    })

    # Dimensionless k coefficients
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.4 Creating Dimensionless Ratios: k Coefficients"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(r\"\"\"\n",
            "### üéØ From Means to Shape Coefficients\n",
            "\n",
            "**Key Insight**: The RATIO $k = \\frac{GM}{AM}$ is special:\n",
            "\n",
            "#### Properties of k:\n",
            "\n",
            "1. **Dimensionless**: No units (pure number)\n",
            "   - Doesn't matter if inputs are seconds, dollars, or utilities\n",
            "\n",
            "2. **Scale-invariant**: $k(2, 8) = k(20, 80) = k(200, 800)$\n",
            "   - Only the RATIO matters, not absolute scale\n",
            "\n",
            "3. **Bounded**: $k \\in [0, 1]$\n",
            "   - 0 = severe imbalance (specialist)\n",
            "   - 1 = perfect balance (generalist)\n",
            "\n",
            "4. **Interpretable**: Geometric meaning\n",
            "   - k close to 1: values are similar\n",
            "   - k close to 0: one value dominates\n",
            "\n",
            "### Mathematical Formula:\n",
            "\n",
            "$$k = \\frac{GM}{AM} = \\frac{\\sqrt{ab}}{\\frac{a+b}{2}} = \\frac{2\\sqrt{ab}}{a+b}$$\n",
            "\n",
            "**When is k = 1?** When $a = b$ (perfect balance)\n",
            "\n",
            "**When is k ‚Üí 0?** When $a \\ll b$ or $b \\ll a$ (specialist)\n",
            "\n",
            "---\n",
            "\n",
            "### üí° Why This Matters for AI\n",
            "\n",
            "We can use k to create **scale-invariant metrics** that:\n",
            "- Transfer across domains\n",
            "- Are interpretable\n",
            "- Don't change behavior (100% fidelity)\n",
            "\n",
            "Let's apply this to our skills!\n",
            "\"\"\"))"
        ]
    })

    # k_explore coefficient
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.5 Silver Gauge Coefficient #1: k_explore"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(r\"\"\"\n",
            "### üîç k_explore: Balance Between Goal and Info\n",
            "\n",
            "**Question**: Does this skill balance goal achievement and information gain?\n",
            "\n",
            "**Inputs**:\n",
            "- $a$ = goal value (pragmatic component)\n",
            "- $b$ = info gain (epistemic component)\n",
            "\n",
            "**Calculation**:\n",
            "$$k_{\\text{explore}} = \\frac{GM(\\text{goal}, \\text{info})}{AM(\\text{goal}, \\text{info})} = \\frac{2\\sqrt{\\text{goal} \\cdot \\text{info}}}{\\text{goal} + \\text{info}}$$\n",
            "\n",
            "**Interpretation**:\n",
            "- $k_{\\text{explore}} \\approx 1$: **Balanced** multi-objective skill\n",
            "- $k_{\\text{explore}} \\approx 0$: **Specialist** (pure exploration OR pure exploitation)\n",
            "\n",
            "### ‚ö†Ô∏è Critical Insight\n",
            "\n",
            "A **pure exploration** skill (info=100%, goal=0%) has $k \\approx 0$!\n",
            "\n",
            "A **pure exploitation** skill (goal=100%, info=0%) also has $k \\approx 0$!\n",
            "\n",
            "**Both are specialists** - just in opposite directions!\n",
            "\n",
            "Only **multi-objective** skills (goal AND info both substantial) have $k > 0.5$!\n",
            "\n",
            "---\n",
            "\n",
            "### üíª Code Implementation\n",
            "\"\"\"))\n",
            "\n",
            "print(\"\"\"\n",
            "def silver_k_explore(goal_value: float, info_gain: float) -> float:\n",
            "    '''\n",
            "    Calculate k_explore coefficient using Pythagorean means.\n",
            "    \n",
            "    Args:\n",
            "        goal_value: Expected goal achievement [0, 1]\n",
            "        info_gain: Expected information gain [0, 1]\n",
            "    \n",
            "    Returns:\n",
            "        k_explore ‚àà [0, 1] where 1 = perfect balance, 0 = specialist\n",
            "    '''\n",
            "    epsilon = 1e-10  # Avoid division by zero\n",
            "    \n",
            "    # Geometric mean: balanced multiplier\n",
            "    gm = np.sqrt(goal_value * info_gain + epsilon)\n",
            "    \n",
            "    # Arithmetic mean: fair splitter\n",
            "    am = (goal_value + info_gain) / 2.0 + epsilon\n",
            "    \n",
            "    # Dimensionless ratio\n",
            "    k = gm / am\n",
            "    \n",
            "    return k\n",
            "\"\"\")\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### ‚úÖ Mathematical Proof of Behavioral Fidelity\n",
            "\n",
            "**Claim**: Silver Gauge doesn't change which skill has minimum EFE\n",
            "\n",
            "**Proof**:\n",
            "1. EFE uses: `cost`, `goal_value`, `info_gain`\n",
            "2. Silver Gauge uses: `goal_value`, `info_gain` (same inputs!)\n",
            "3. Silver Gauge is a **pure function** - no side effects\n",
            "4. Argmin(EFE) is unchanged\n",
            "\n",
            "**Therefore**: 100% behavioral fidelity guaranteed!\n",
            "\n",
            "We've added a diagnostic layer without changing the model!\n",
            "\"\"\"))"
        ]
    })

    # THE REVELATION
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.6 üéâ THE REVELATION: Calculate k_explore for Our Skills"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### üî¨ Applying Silver Gauge to Crisp Skills\n",
            "\n",
            "Let's calculate k_explore for our three skills:\n",
            "- peek_door: goal=0.0, info=1.0\n",
            "- try_door: goal=1.0, info=0.0\n",
            "- go_window: goal=1.0, info=0.0\n",
            "\n",
            "What do you **predict** k_explore will be?\n",
            "\"\"\"))\n",
            "\n",
            "def calculate_silver_for_crisp():\n",
            "    \"\"\"Calculate Silver Gauge metrics for crisp skills\"\"\"\n",
            "    skills_data = [\n",
            "        {'name': 'peek_door', 'goal': 0.0, 'info': 1.0, 'cost': 1.0},\n",
            "        {'name': 'try_door', 'goal': 1.0, 'info': 0.0, 'cost': 1.5},\n",
            "        {'name': 'go_window', 'goal': 1.0, 'info': 0.0, 'cost': 2.0}\n",
            "    ]\n",
            "    \n",
            "    results = []\n",
            "    for skill in skills_data:\n",
            "        k_exp = silver_k_explore(skill['goal'], skill['info'])\n",
            "        benefit = skill['goal'] + skill['info']\n",
            "        k_eff = silver_k_efficiency(benefit, skill['cost'])\n",
            "        \n",
            "        results.append({\n",
            "            'Skill': skill['name'],\n",
            "            'Goal': skill['goal'],\n",
            "            'Info': skill['info'],\n",
            "            'Cost': skill['cost'],\n",
            "            'k_explore': k_exp,\n",
            "            'k_efficiency': k_eff\n",
            "        })\n",
            "    \n",
            "    return pd.DataFrame(results)\n",
            "\n",
            "df_silver_crisp = calculate_silver_for_crisp()\n",
            "\n",
            "print(\"\\n\" + \"=\"*70)\n",
            "print(\"SILVER GAUGE ANALYSIS: CRISP SKILLS\")\n",
            "print(\"=\"*70 + \"\\n\")\n",
            "print(df_silver_crisp.to_string(index=False))\n",
            "print(\"\\n\" + \"=\"*70)\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üò± WAIT... WHAT?!\n",
            "\n",
            "Look at the **k_explore** column:\n",
            "\n",
            "- **peek_door**: k ‚âà 0.0001 (specialist!)\n",
            "- **try_door**: k ‚âà 0.0000 (specialist!)\n",
            "- **go_window**: k ‚âà 0.0000 (specialist!)\n",
            "\n",
            "## üéØ THE BIG DISCOVERY üéØ\n",
            "\n",
            "**ALL crisp skills have k ‚âà 0!**\n",
            "\n",
            "### Why?\n",
            "\n",
            "- **peek_door**: goal=0, info=1 ‚Üí IMBALANCED ‚Üí k‚âà0\n",
            "- **try_door**: goal=1, info=0 ‚Üí IMBALANCED ‚Üí k‚âà0\n",
            "\n",
            "**Both exploration AND exploitation are specialists!**\n",
            "\n",
            "They're just specialists in **opposite directions**:\n",
            "- peek = 100% info, 0% goal\n",
            "- try = 100% goal, 0% info\n",
            "\n",
            "### üí° The Profound Insight\n",
            "\n",
            "**k_explore doesn't measure \"explore vs exploit\"**\n",
            "\n",
            "**k_explore measures \"specialist vs generalist\"**\n",
            "\n",
            "- k‚âà0: Specialist (extreme in one direction)\n",
            "- k‚âà1: Generalist (balanced multi-objective)\n",
            "\n",
            "### ‚ö†Ô∏è The Gap\n",
            "\n",
            "**No skills exist in the multi-objective zone (k > 0.5)!**\n",
            "\n",
            "All our skills cluster at k‚âà0. There's a huge geometric gap!\n",
            "\n",
            "This gap will inspire the next innovation...\n",
            "\"\"\"))"
        ]
    })

    # Geometric gap visualization
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.7 Visualizing the Geometric Gap"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### üìä The Empty Multi-Objective Zone\n",
            "\"\"\"))\n",
            "\n",
            "# Scatter plot of skills in geometric space\n",
            "fig, ax = plt.subplots(figsize=(14, 10))\n",
            "\n",
            "for idx, row in df_silver_crisp.iterrows():\n",
            "    k_exp = row['k_explore']\n",
            "    k_eff = row['k_efficiency']\n",
            "    skill_name = row['Skill']\n",
            "    \n",
            "    # Determine color by type\n",
            "    if 'peek' in skill_name:\n",
            "        color = COLORS['sense']\n",
            "        marker = 'o'\n",
            "    else:\n",
            "        color = COLORS['act']\n",
            "        marker = 's'\n",
            "    \n",
            "    # Plot point\n",
            "    ax.scatter(k_exp, k_eff, s=600, alpha=0.8, color=color, marker=marker,\n",
            "              edgecolors='black', linewidth=3, zorder=5)\n",
            "    \n",
            "    # Add label\n",
            "    ax.annotate(skill_name, (k_exp, k_eff), fontsize=12, fontweight='bold',\n",
            "               xytext=(15, 15), textcoords='offset points',\n",
            "               bbox=dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.8),\n",
            "               arrowprops=dict(arrowstyle='->', lw=2))\n",
            "\n",
            "# Highlight zones\n",
            "ax.axvspan(0.5, 1.0, alpha=0.15, color='green', label='Multi-objective zone (EMPTY!)', zorder=1)\n",
            "ax.axvspan(0.0, 0.1, alpha=0.15, color='red', label='Specialist zone (ALL skills here!)', zorder=1)\n",
            "\n",
            "# Add text annotations for zones\n",
            "ax.text(0.75, 0.9, 'MULTI-OBJECTIVE\\nZONE\\n\\n(EMPTY!)', \n",
            "       ha='center', va='center', fontsize=16, fontweight='bold',\n",
            "       bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.5, edgecolor='darkgreen', linewidth=3))\n",
            "\n",
            "ax.text(0.05, 0.5, 'SPECIALIST\\nZONE\\n\\n(crowded!)', \n",
            "       ha='center', va='center', fontsize=14, fontweight='bold',\n",
            "       bbox=dict(boxstyle='round', facecolor='lightcoral', alpha=0.5, edgecolor='darkred', linewidth=3))\n",
            "\n",
            "ax.set_xlabel('k_explore (specialist ‚Üê 0 ... 1 ‚Üí balanced)', fontsize=14, fontweight='bold')\n",
            "ax.set_ylabel('k_efficiency (poor ‚Üê 0 ... 1 ‚Üí excellent)', fontsize=14, fontweight='bold')\n",
            "ax.set_title('Geometric Fingerprints of Crisp Skills\\n‚ö† GAP REVEALED: Multi-Objective Zone is Empty!',\n",
            "            fontsize=16, fontweight='bold', pad=20)\n",
            "ax.set_xlim(-0.05, 1.05)\n",
            "ax.set_ylim(-0.05, 1.05)\n",
            "ax.grid(alpha=0.3, linestyle='--')\n",
            "ax.legend(fontsize=12, loc='upper right', framealpha=0.9)\n",
            "\n",
            "# Add diagonal reference line\n",
            "ax.plot([0, 1], [0, 1], 'k:', alpha=0.3, linewidth=1, label='k_explore = k_efficiency')\n",
            "\n",
            "plt.tight_layout()\n",
            "plt.show()\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üéØ What This Diagram Shows\n",
            "\n",
            "**X-axis (k_explore)**:\n",
            "- Left (k‚âà0): Specialist skills\n",
            "- Right (k‚âà1): Balanced multi-objective skills\n",
            "\n",
            "**Y-axis (k_efficiency)**:\n",
            "- Bottom (k‚âà0): Poor benefit/cost ratio\n",
            "- Top (k‚âà1): Excellent benefit/cost ratio\n",
            "\n",
            "**The Gap**:\n",
            "- ALL crisp skills cluster at x‚âà0 (specialist zone)\n",
            "- NONE exist in x>0.5 (multi-objective zone)\n",
            "- This is an **architectural gap**, not a bug!\n",
            "\n",
            "---\n",
            "\n",
            "## üî¨ The Diagnostic-Driven Design Pattern\n",
            "\n",
            "**What just happened**:\n",
            "\n",
            "1. ‚úÖ Built sophisticated diagnostic (Silver Gauge)\n",
            "2. ‚úÖ Applied to system (crisp skills)\n",
            "3. ‚úÖ **Diagnostic revealed gap** (k ‚âà 0 everywhere) ‚Üê WE ARE HERE\n",
            "4. ‚Üí Gap inspires solution (balanced skills) ‚Üê NEXT PART!\n",
            "5. ‚Üí Solution showcases diagnostic's value\n",
            "\n",
            "This is a **general pattern** applicable beyond this project!\n",
            "\"\"\"))"
        ]
    })

    # Checkpoint 4
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 4.8 Checkpoint 4: Design a Balanced Skill"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### ‚úÖ Checkpoint 4: Your Turn!\n",
            "\n",
            "**Challenge**: Design a skill with k_explore > 0.7\n",
            "\n",
            "Adjust the sliders to create a balanced multi-objective skill:\n",
            "\"\"\"))\n",
            "\n",
            "goal_frac_slider = widgets.FloatSlider(\n",
            "    value=0.5, min=0, max=1, step=0.05,\n",
            "    description='Goal fraction:',\n",
            "    style={'description_width': 'initial'}\n",
            ")\n",
            "info_frac_slider = widgets.FloatSlider(\n",
            "    value=0.5, min=0, max=1, step=0.05,\n",
            "    description='Info fraction:',\n",
            "    style={'description_width': 'initial'}\n",
            ")\n",
            "\n",
            "challenge_output = widgets.Output()\n",
            "\n",
            "def calculate_k_design(change):\n",
            "    goal_frac = goal_frac_slider.value\n",
            "    info_frac = info_frac_slider.value\n",
            "    \n",
            "    with challenge_output:\n",
            "        clear_output(wait=True)\n",
            "        \n",
            "        k = silver_k_explore(goal_frac, info_frac)\n",
            "        \n",
            "        # Visual feedback\n",
            "        fig, ax = plt.subplots(figsize=(12, 4))\n",
            "        \n",
            "        # Bar showing k value\n",
            "        color = '#2ecc71' if k > 0.7 else ('#f39c12' if k > 0.5 else '#e74c3c')\n",
            "        ax.barh(['k_explore'], [k], color=color, alpha=0.7, \n",
            "               edgecolor='black', linewidth=2, height=0.5)\n",
            "        ax.set_xlim(0, 1)\n",
            "        ax.set_xlabel('k_explore', fontsize=12, fontweight='bold')\n",
            "        ax.axvline(x=0.7, color='green', linestyle='--', linewidth=2, \n",
            "                  label='Target (k=0.7)', alpha=0.7)\n",
            "        ax.axvline(x=0.5, color='orange', linestyle='--', linewidth=2, \n",
            "                  label='Multi-objective threshold (k=0.5)', alpha=0.7)\n",
            "        ax.legend(fontsize=10)\n",
            "        ax.set_title(f'Your Skill Design: k_explore = {k:.4f}', \n",
            "                    fontsize=14, fontweight='bold')\n",
            "        \n",
            "        # Add value label\n",
            "        ax.text(k, 0, f'{k:.3f}', ha='center', va='center',\n",
            "               fontsize=14, fontweight='bold', color='white',\n",
            "               bbox=dict(boxstyle='circle', facecolor='black'))\n",
            "        \n",
            "        plt.tight_layout()\n",
            "        plt.show()\n",
            "        \n",
            "        # Text feedback\n",
            "        print(\"=\"*70)\n",
            "        print(f\"Skill Design:\")\n",
            "        print(f\"  Goal fraction: {goal_frac:.2f}\")\n",
            "        print(f\"  Info fraction: {info_frac:.2f}\")\n",
            "        print(f\"  k_explore: {k:.4f}\")\n",
            "        print(\"=\"*70)\n",
            "        \n",
            "        if k > 0.9:\n",
            "            print(\"\\n‚úì‚úì‚úì EXCELLENT! Nearly perfect balance! (a ‚âà b)\")\n",
            "            print(\"    This skill provides BOTH goal AND info effectively!\")\n",
            "        elif k > 0.7:\n",
            "            print(\"\\n‚úì‚úì GREAT! Multi-objective skill achieved!\")\n",
            "            print(\"    You've filled the geometric gap!\")\n",
            "        elif k > 0.5:\n",
            "            print(\"\\n‚úì GOOD! You've crossed into multi-objective territory!\")\n",
            "            print(\"    Can you get even more balanced?\")\n",
            "        else:\n",
            "            print(\"\\n‚ö† Still too specialized.\")\n",
            "            print(\"    Hint: Both goal AND info need to be substantial!\")\n",
            "\n",
            "goal_frac_slider.observe(calculate_k_design, names='value')\n",
            "info_frac_slider.observe(calculate_k_design, names='value')\n",
            "\n",
            "display(goal_frac_slider, info_frac_slider, challenge_output)\n",
            "calculate_k_design(None)  # Initial\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üí° Hint\n",
            "\n",
            "To maximize k_explore:\n",
            "- Need **both** goal and info to be high\n",
            "- Perfect balance: goal = info = 0.7\n",
            "- Try: goal=0.7, info=0.7 ‚Üí k ‚âà 1.0!\n",
            "\"\"\"))"
        ]
    })

    # Part 4 Summary
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "---\n",
            "\n",
            "### üéØ Part 4 Summary: THE REVELATION\n",
            "\n",
            "**What we discovered**:\n",
            "\n",
            "1. ‚úÖ **Pythagorean means** (HM, GM, AM) create interpretable diagnostics\n",
            "2. ‚úÖ **k = GM/AM** is dimensionless, scale-invariant, bounded [0,1]\n",
            "3. ‚úÖ **k_explore** measures specialist (k‚âà0) vs generalist (k‚âà1)\n",
            "4. ‚úÖ **ALL crisp skills have k‚âà0** - even exploration and exploitation!\n",
            "5. ‚úÖ **Both are specialists** - just in opposite directions\n",
            "6. ‚úÖ **Geometric gap revealed** - no skills in multi-objective zone (k>0.5)\n",
            "7. ‚úÖ **100% behavioral fidelity** - diagnostic doesn't change EFE\n",
            "8. ‚úÖ **Diagnostic-driven design** - gap inspires solution\n",
            "\n",
            "### ü§Ø The Mind-Blowing Insight\n",
            "\n",
            "**k_explore ‚â† \"explore vs exploit\"**\n",
            "\n",
            "**k_explore = \"specialist vs generalist\"**\n",
            "\n",
            "Pure exploration (peek) and pure exploitation (try) are **both specialists** (k‚âà0)!\n",
            "\n",
            "### üé™ What's Next?\n",
            "\n",
            "We've identified a geometric gap. How do we fill it?\n",
            "\n",
            "‚Üí **Multi-Objective Skills** (Balanced Skills)\n",
            "\n",
            "Skills that provide **BOTH** goal achievement **AND** information gain!\n",
            "\n",
            "---\n",
            "\n",
            "**Next**: How do we create balanced skills? ‚Üí **Multi-Objective Evolution!**"
        ]
    })

    return cells


def append_to_notebook(notebook_path, cells):
    """Append cells to notebook"""
    with open(notebook_path, 'r') as f:
        nb = json.load(f)

    nb['cells'].extend(cells)

    with open(notebook_path, 'w') as f:
        json.dump(nb, f, indent=1)

    print(f"‚úì Added {len(cells)} cells")


if __name__ == "__main__":
    notebook_path = "/home/juancho/macgyver_mud/MacGyverMUD_DeepDive.ipynb"

    print("Creating Part 4: Silver Gauge Revelation (THE CLIMAX!)...")
    cells = create_part4_cells()

    print(f"Total cells in Part 4: {len(cells)}")
    print("\\nAppending to notebook...")
    append_to_notebook(notebook_path, cells)

    print("\\n‚úì Part 4 added successfully!")
    print("  This is THE CLIMAX - the k‚âà0 revelation!")
