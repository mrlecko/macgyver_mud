#!/usr/bin/env python3
"""
Build Part 3: Belief Updates & Procedural Memory
THE MISSING BRIDGE between Part 2 (EFE) and Part 4 (Silver Gauge)
"""

import json

def create_part3_cells():
    """Part 3: Policy Execution, Belief Updates, and Procedural Memory"""
    cells = []

    # Part 3 Header
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "---\n",
            "\n",
            "# PART 3: Policy Execution & Learning\n",
            "\n",
            "**Time**: 25 minutes\n",
            "\n",
            "**Goals**:\n",
            "- Understand how beliefs UPDATE after observations\n",
            "- See Bayesian inference in action\n",
            "- Explore procedural memory networks\n",
            "- Simulate a complete episode\n",
            "- Visualize the knowledge graph\n",
            "\n",
            "**The bridge**: From scoring skills ‚Üí to understanding agent behavior"
        ]
    })

    # 3.1 Database Schema
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 3.1 The Knowledge Graph: Database Schema"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### üóÑÔ∏è What's in Our Neo4j Database?\n",
            "\n",
            "Before we dive into execution, let's understand the graph structure:\n",
            "\"\"\"))\n",
            "\n",
            "if NEO4J_CONNECTED:\n",
            "    # Get schema information\n",
            "    schema_info = run_query(\"\"\"\n",
            "        CALL db.labels() YIELD label\n",
            "        RETURN label, count{(n) WHERE label IN labels(n)} as count\n",
            "        ORDER BY count DESC\n",
            "    \"\"\")\n",
            "    \n",
            "    print(\"\\nüìä Node Types in Database:\")\n",
            "    print(\"=\" * 50)\n",
            "    for item in schema_info:\n",
            "        print(f\"  {item['label']:20s}: {item['count']:3d} nodes\")\n",
            "    \n",
            "    # Get relationship types\n",
            "    rel_info = run_query(\"\"\"\n",
            "        CALL db.relationshipTypes() YIELD relationshipType\n",
            "        RETURN relationshipType, \n",
            "               count{()-[r]-() WHERE type(r) = relationshipType} as count\n",
            "        ORDER BY count DESC\n",
            "    \"\"\")\n",
            "    \n",
            "    print(\"\\nüîó Relationship Types:\")\n",
            "    print(\"=\" * 50)\n",
            "    for item in rel_info:\n",
            "        print(f\"  {item['relationshipType']:20s}: {item['count']:3d} relationships\")\n",
            "    \n",
            "    # Visualize schema\n",
            "    fig, ax = plt.subplots(figsize=(14, 10))\n",
            "    \n",
            "    # Create schema graph\n",
            "    G_schema = nx.DiGraph()\n",
            "    \n",
            "    # Define schema (conceptual)\n",
            "    schema_nodes = {\n",
            "        'Agent': {'color': '#3498db', 'pos': (0, 3)},\n",
            "        'State': {'color': '#e74c3c', 'pos': (-2, 1)},\n",
            "        'Skill': {'color': '#2ecc71', 'pos': (2, 1)},\n",
            "        'Observation': {'color': '#f39c12', 'pos': (-2, -1)},\n",
            "        'Memory': {'color': '#9b59b6', 'pos': (2, -1)}\n",
            "    }\n",
            "    \n",
            "    schema_edges = [\n",
            "        ('Agent', 'State', 'IN_STATE'),\n",
            "        ('Agent', 'Skill', 'CAN_USE'),\n",
            "        ('State', 'State', 'LEADS_TO'),\n",
            "        ('State', 'Observation', 'YIELDS'),\n",
            "        ('Skill', 'Observation', 'PRODUCES'),\n",
            "        ('Memory', 'Skill', 'RECOMMENDS')\n",
            "    ]\n",
            "    \n",
            "    for node, attrs in schema_nodes.items():\n",
            "        G_schema.add_node(node, **attrs)\n",
            "    \n",
            "    for src, dst, label in schema_edges:\n",
            "        G_schema.add_edge(src, dst, label=label)\n",
            "    \n",
            "    # Position nodes\n",
            "    pos = {node: attrs['pos'] for node, attrs in schema_nodes.items()}\n",
            "    \n",
            "    # Draw\n",
            "    node_colors = [schema_nodes[node]['color'] for node in G_schema.nodes()]\n",
            "    nx.draw_networkx_nodes(G_schema, pos, node_color=node_colors,\n",
            "                          node_size=3000, alpha=0.9, edgecolors='black', linewidths=2)\n",
            "    nx.draw_networkx_labels(G_schema, pos, font_size=12, font_weight='bold')\n",
            "    \n",
            "    # Draw edges with labels\n",
            "    nx.draw_networkx_edges(G_schema, pos, width=2, alpha=0.6,\n",
            "                          arrows=True, arrowsize=20, arrowstyle='-|>',\n",
            "                          connectionstyle='arc3,rad=0.1')\n",
            "    \n",
            "    edge_labels = {(e[0], e[1]): e[2] for e in schema_edges}\n",
            "    nx.draw_networkx_edge_labels(G_schema, pos, edge_labels, font_size=9)\n",
            "    \n",
            "    ax.set_title('MacGyver MUD Knowledge Graph Schema', \n",
            "                fontsize=16, fontweight='bold', pad=20)\n",
            "    ax.axis('off')\n",
            "    plt.tight_layout()\n",
            "    plt.show()\n",
            "    \n",
            "else:\n",
            "    print(\"\\n‚ö† Neo4j not connected. Showing conceptual schema.\")\n",
            "    print(\"\\nKey Node Types:\")\n",
            "    print(\"  - Agent: The decision-maker\")\n",
            "    print(\"  - State: Room states (stuck, escaped, etc.)\")\n",
            "    print(\"  - Skill: Available actions (peek, try, window)\")\n",
            "    print(\"  - Observation: What the agent perceives\")\n",
            "    print(\"  - Memory: Learned patterns (context ‚Üí skill)\")\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üìñ Understanding the Schema\n",
            "\n",
            "**Nodes (Entities)**:\n",
            "- ü§ñ **Agent**: The decision-making entity (MacGyverBot)\n",
            "- üö™ **State**: Possible world states (stuck_in_room, escaped, etc.)\n",
            "- üõ† **Skill**: Available actions (peek_door, try_door, go_window)\n",
            "- üëÅ **Observation**: What the agent perceives after actions\n",
            "- üß† **Memory**: Learned associations (context ‚Üí recommended skill)\n",
            "\n",
            "**Relationships (Connections)**:\n",
            "- `CAN_USE`: Agent can use certain skills\n",
            "- `LEADS_TO`: State transitions (stuck ‚Üí escaped)\n",
            "- `PRODUCES`: Skills produce observations\n",
            "- `RECOMMENDS`: Memories recommend skills for contexts\n",
            "- `YIELDS`: States can yield observations\n",
            "\n",
            "This graph structure enables:\n",
            "1. **Planning**: Find paths from stuck ‚Üí escaped\n",
            "2. **Learning**: Store context ‚Üí skill patterns\n",
            "3. **Reasoning**: Query relationships and patterns\n",
            "\"\"\"))"
        ]
    })

    # 3.2 Bayesian Belief Updates
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 3.2 How Beliefs Update: Bayesian Inference"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(r\"\"\"\n",
            "### üîÑ From Uncertainty to Knowledge\n",
            "\n",
            "When the agent executes `peek_door`, it observes something. How does this update beliefs?\n",
            "\n",
            "**Bayes' Rule**:\n",
            "\n",
            "$$P(\\text{Locked} | \\text{observation}) = \\frac{P(\\text{observation} | \\text{Locked}) \\cdot P(\\text{Locked})}{P(\\text{observation})}$$\n",
            "\n",
            "**In English**:\n",
            "- **Prior**: P(Locked) = initial belief before peeking\n",
            "- **Likelihood**: P(obs|Locked) = how likely this observation if door is locked\n",
            "- **Posterior**: P(Locked|obs) = updated belief after observation\n",
            "\n",
            "**Example**:\n",
            "- Prior: 50% chance door is locked\n",
            "- Action: peek_door\n",
            "- Observation: \"obs_door_locked\"\n",
            "- Likelihood: If locked, 95% chance we observe \"locked\" (sensing accuracy)\n",
            "- Posterior: ~95% chance door is locked (updated!)\n",
            "\n",
            "Let's see this in action!\n",
            "\"\"\"))\n",
            "\n",
            "# Interactive belief update simulator\n",
            "def simulate_belief_update(prior_locked, true_state, action):\n",
            "    \"\"\"\n",
            "    Simulate one belief update step.\n",
            "    \n",
            "    Args:\n",
            "        prior_locked: Prior belief that door is locked (0-1)\n",
            "        true_state: True door state ('locked' or 'unlocked')\n",
            "        action: Action taken ('peek_door', 'try_door')\n",
            "    \n",
            "    Returns:\n",
            "        posterior_locked, observation\n",
            "    \"\"\"\n",
            "    # Sensing accuracy\n",
            "    accuracy = 0.95\n",
            "    \n",
            "    if action == 'peek_door':\n",
            "        # Generate observation based on true state\n",
            "        if true_state == 'locked':\n",
            "            obs = 'obs_door_locked' if np.random.random() < accuracy else 'obs_door_unlocked'\n",
            "        else:\n",
            "            obs = 'obs_door_unlocked' if np.random.random() < accuracy else 'obs_door_locked'\n",
            "        \n",
            "        # Bayesian update\n",
            "        if obs == 'obs_door_locked':\n",
            "            # P(Locked|obs_locked) using Bayes\n",
            "            likelihood_locked = accuracy\n",
            "            likelihood_unlocked = 1 - accuracy\n",
            "            \n",
            "            numerator = likelihood_locked * prior_locked\n",
            "            denominator = (likelihood_locked * prior_locked + \n",
            "                          likelihood_unlocked * (1 - prior_locked))\n",
            "            posterior_locked = numerator / denominator\n",
            "        else:\n",
            "            # P(Locked|obs_unlocked)\n",
            "            likelihood_locked = 1 - accuracy\n",
            "            likelihood_unlocked = accuracy\n",
            "            \n",
            "            numerator = likelihood_locked * prior_locked\n",
            "            denominator = (likelihood_locked * prior_locked + \n",
            "                          likelihood_unlocked * (1 - prior_locked))\n",
            "            posterior_locked = numerator / denominator\n",
            "    \n",
            "    elif action == 'try_door':\n",
            "        # Try door gives indirect evidence\n",
            "        if true_state == 'locked':\n",
            "            obs = 'obs_door_still_locked'\n",
            "            posterior_locked = 0.99  # Very confident it's locked\n",
            "        else:\n",
            "            obs = 'obs_escaped'\n",
            "            posterior_locked = 0.0  # Certain it was unlocked!\n",
            "    else:\n",
            "        obs = 'no_observation'\n",
            "        posterior_locked = prior_locked\n",
            "    \n",
            "    return posterior_locked, obs\n",
            "\n",
            "# Interactive widget\n",
            "prior_slider = widgets.FloatSlider(\n",
            "    value=0.5, min=0.01, max=0.99, step=0.01,\n",
            "    description='Prior belief (locked):',\n",
            "    style={'description_width': 'initial'},\n",
            "    readout_format='.0%'\n",
            ")\n",
            "\n",
            "true_state_radio = widgets.RadioButtons(\n",
            "    options=['locked', 'unlocked'],\n",
            "    value='locked',\n",
            "    description='True state:',\n",
            "    style={'description_width': 'initial'}\n",
            ")\n",
            "\n",
            "action_radio = widgets.RadioButtons(\n",
            "    options=['peek_door', 'try_door'],\n",
            "    value='peek_door',\n",
            "    description='Action:',\n",
            "    style={'description_width': 'initial'}\n",
            ")\n",
            "\n",
            "update_button = widgets.Button(\n",
            "    description='Execute Action',\n",
            "    button_style='primary',\n",
            "    icon='play'\n",
            ")\n",
            "\n",
            "update_output = widgets.Output()\n",
            "\n",
            "def on_update_click(b):\n",
            "    with update_output:\n",
            "        clear_output(wait=True)\n",
            "        \n",
            "        prior = prior_slider.value\n",
            "        true_state = true_state_radio.value\n",
            "        action = action_radio.value\n",
            "        \n",
            "        posterior, obs = simulate_belief_update(prior, true_state, action)\n",
            "        \n",
            "        # Visualize\n",
            "        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(16, 5))\n",
            "        \n",
            "        # Prior\n",
            "        ax1.bar(['Unlocked', 'Locked'], [1-prior, prior], \n",
            "               color=['#2ecc71', '#e74c3c'], alpha=0.7, edgecolor='black', linewidth=2)\n",
            "        ax1.set_ylim(0, 1.1)\n",
            "        ax1.set_ylabel('Probability', fontsize=12)\n",
            "        ax1.set_title('BEFORE: Prior Belief', fontsize=14, fontweight='bold')\n",
            "        ax1.text(0, 1-prior+0.02, f'{1-prior:.0%}', ha='center', fontsize=14, fontweight='bold')\n",
            "        ax1.text(1, prior+0.02, f'{prior:.0%}', ha='center', fontsize=14, fontweight='bold')\n",
            "        ax1.grid(axis='y', alpha=0.3)\n",
            "        \n",
            "        # Action\n",
            "        ax2.axis('off')\n",
            "        ax2.text(0.5, 0.7, f'Action: {action}', ha='center', va='center',\n",
            "                fontsize=16, fontweight='bold',\n",
            "                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.7))\n",
            "        ax2.text(0.5, 0.5, f'Observation:\\n{obs}', ha='center', va='center',\n",
            "                fontsize=14, style='italic',\n",
            "                bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.7))\n",
            "        ax2.text(0.5, 0.3, f'True state: {true_state}\\n(hidden from agent)', \n",
            "                ha='center', va='center', fontsize=11, color='gray')\n",
            "        ax2.set_xlim(0, 1)\n",
            "        ax2.set_ylim(0, 1)\n",
            "        \n",
            "        # Posterior\n",
            "        ax3.bar(['Unlocked', 'Locked'], [1-posterior, posterior],\n",
            "               color=['#2ecc71', '#e74c3c'], alpha=0.7, edgecolor='black', linewidth=2)\n",
            "        ax3.set_ylim(0, 1.1)\n",
            "        ax3.set_ylabel('Probability', fontsize=12)\n",
            "        ax3.set_title('AFTER: Posterior Belief', fontsize=14, fontweight='bold')\n",
            "        ax3.text(0, 1-posterior+0.02, f'{1-posterior:.0%}', ha='center', fontsize=14, fontweight='bold')\n",
            "        ax3.text(1, posterior+0.02, f'{posterior:.0%}', ha='center', fontsize=14, fontweight='bold')\n",
            "        ax3.grid(axis='y', alpha=0.3)\n",
            "        \n",
            "        plt.tight_layout()\n",
            "        plt.show()\n",
            "        \n",
            "        # Summary\n",
            "        print(\"\\n\" + \"=\"*70)\n",
            "        print(\"BAYESIAN UPDATE SUMMARY\")\n",
            "        print(\"=\"*70)\n",
            "        print(f\"Prior belief (Locked):     {prior:.2%}\")\n",
            "        print(f\"Action taken:              {action}\")\n",
            "        print(f\"Observation received:      {obs}\")\n",
            "        print(f\"Posterior belief (Locked): {posterior:.2%}\")\n",
            "        print(\"-\"*70)\n",
            "        change = posterior - prior\n",
            "        print(f\"Belief change:             {change:+.2%}\")\n",
            "        print(f\"Information gained:        {abs(change):.2%}\")\n",
            "        print(\"=\"*70)\n",
            "        \n",
            "        if abs(change) > 0.3:\n",
            "            print(\"\\n‚úì Significant information gained!\")\n",
            "        elif abs(change) > 0.1:\n",
            "            print(\"\\n~ Moderate information gained.\")\n",
            "        else:\n",
            "            print(\"\\n‚ö† Minimal information gained (already confident).\")\n",
            "\n",
            "update_button.on_click(on_update_click)\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üéÆ Interactive Belief Update Simulator\n",
            "\n",
            "Try different scenarios:\n",
            "1. Prior=50%, True=locked, Action=peek ‚Üí See confidence increase\n",
            "2. Prior=80%, True=unlocked, Action=peek ‚Üí See surprise! (belief reversal)\n",
            "3. Prior=50%, True=unlocked, Action=try_door ‚Üí Immediate certainty!\n",
            "\"\"\"))\n",
            "\n",
            "display(widgets.VBox([\n",
            "    prior_slider,\n",
            "    true_state_radio,\n",
            "    action_radio,\n",
            "    update_button\n",
            "]))\n",
            "display(update_output)"
        ]
    })

    # 3.3 Procedural Memory
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 3.3 Procedural Memory: Learning from Experience"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### üß† How the Agent Learns Patterns\n",
            "\n",
            "**Procedural Memory** = Learned associations between contexts and skills\n",
            "\n",
            "**Structure**: `(context_pattern) ‚Üí recommended_skill (confidence)`\n",
            "\n",
            "**Example Memories**:\n",
            "- \"When belief > 0.7 AND tried=false ‚Üí peek_door\" (confidence: 0.9)\n",
            "- \"When tried=true AND failed ‚Üí go_window\" (confidence: 0.8)\n",
            "\n",
            "**How it works**:\n",
            "1. Agent executes episodes\n",
            "2. Successful paths remembered\n",
            "3. Context patterns extracted\n",
            "4. Future decisions influenced by memories\n",
            "\n",
            "Let's visualize the memory network!\n",
            "\"\"\"))\n",
            "\n",
            "if NEO4J_CONNECTED:\n",
            "    # Query procedural memories\n",
            "    memories = run_query(\"\"\"\n",
            "        MATCH (m:Memory)-[r:RECOMMENDS]->(s:Skill)\n",
            "        RETURN m.context as context, \n",
            "               s.name as skill, \n",
            "               r.confidence as confidence\n",
            "        ORDER BY r.confidence DESC\n",
            "        LIMIT 10\n",
            "    \"\"\")\n",
            "    \n",
            "    if memories:\n",
            "        print(\"\\nüìö Top 10 Procedural Memories:\")\n",
            "        print(\"=\" * 70)\n",
            "        for i, mem in enumerate(memories, 1):\n",
            "            print(f\"\\n{i}. Context: {mem['context']}\")\n",
            "            print(f\"   ‚Üí Recommends: {mem['skill']}\")\n",
            "            print(f\"   ‚Üí Confidence: {mem['confidence']:.2f}\")\n",
            "        \n",
            "        # Visualize memory network\n",
            "        fig, ax = plt.subplots(figsize=(14, 10))\n",
            "        G_mem = nx.DiGraph()\n",
            "        \n",
            "        for mem in memories:\n",
            "            context_node = mem['context'][:30] + '...' if len(mem['context']) > 30 else mem['context']\n",
            "            G_mem.add_edge(context_node, mem['skill'], \n",
            "                          weight=mem['confidence'])\n",
            "        \n",
            "        pos = nx.spring_layout(G_mem, k=2, iterations=50)\n",
            "        \n",
            "        # Color by node type\n",
            "        node_colors = ['#9b59b6' if 'belief' in node.lower() or 'tried' in node.lower() \n",
            "                      else '#2ecc71' for node in G_mem.nodes()]\n",
            "        \n",
            "        nx.draw(G_mem, pos, with_labels=True, node_color=node_colors,\n",
            "               node_size=2000, font_size=9, font_weight='bold',\n",
            "               arrows=True, edge_color='gray', width=2, alpha=0.7,\n",
            "               arrowsize=15)\n",
            "        \n",
            "        # Add edge labels (confidence)\n",
            "        edge_labels = {(u, v): f\"{d['weight']:.2f}\" \n",
            "                      for u, v, d in G_mem.edges(data=True)}\n",
            "        nx.draw_networkx_edge_labels(G_mem, pos, edge_labels, font_size=8)\n",
            "        \n",
            "        ax.set_title('Procedural Memory Network (Context ‚Üí Skill)', \n",
            "                    fontsize=16, fontweight='bold', pad=20)\n",
            "        ax.axis('off')\n",
            "        plt.tight_layout()\n",
            "        plt.show()\n",
            "    else:\n",
            "        print(\"\\n‚ö† No procedural memories found in database.\")\n",
            "        print(\"   (Memories are created during episodes with --use-memory flag)\")\n",
            "else:\n",
            "    print(\"\\n‚ö† Neo4j not connected. Can't query memories.\")\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üí° How Memories Improve Decision-Making\n",
            "\n",
            "**Without Memory** (Pure EFE):\n",
            "- Calculate EFE for each skill\n",
            "- Pick minimum\n",
            "- No learning across episodes\n",
            "\n",
            "**With Memory** (EFE + Experience):\n",
            "- Calculate EFE\n",
            "- Check if context matches any memory\n",
            "- Boost confidence for recommended skills\n",
            "- Faster convergence to good strategies\n",
            "\n",
            "**Example**:\n",
            "- Context: \"belief=0.8, tried=false\"\n",
            "- Memory says: \"peek_door worked well here before\"\n",
            "- Agent more likely to peek (even if EFE is similar to try)\n",
            "\n",
            "This is **procedural learning** - learning \"what works when\"!\n",
            "\"\"\"))"
        ]
    })

    # 3.4 Full Episode Simulation
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 3.4 Simulating a Complete Episode"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### üé¨ Watch an Agent Episode\n",
            "\n",
            "Let's simulate a complete episode step-by-step:\n",
            "\"\"\"))\n",
            "\n",
            "def simulate_episode(initial_belief, true_door_state, max_steps=5):\n",
            "    \"\"\"\n",
            "    Simulate a complete episode.\n",
            "    \"\"\"\n",
            "    belief = initial_belief\n",
            "    escaped = False\n",
            "    step = 0\n",
            "    history = []\n",
            "    \n",
            "    skills_available = [\n",
            "        {'name': 'peek_door', 'cost': 1.0, 'goal_info': 0.0, 'info_gain': 1.0},\n",
            "        {'name': 'try_door', 'cost': 1.5, 'goal_info': 1.0, 'info_gain': 0.0},\n",
            "        {'name': 'go_window', 'cost': 2.0, 'goal_info': 1.0, 'info_gain': 0.0}\n",
            "    ]\n",
            "    \n",
            "    print(\"\\n\" + \"=\"*70)\n",
            "    print(f\"EPISODE SIMULATION (True state: {true_door_state})\")\n",
            "    print(\"=\"*70)\n",
            "    print(f\"\\nInitial belief (locked): {belief:.2%}\")\n",
            "    print()\n",
            "    \n",
            "    while not escaped and step < max_steps:\n",
            "        step += 1\n",
            "        print(f\"\\n--- STEP {step} ---\")\n",
            "        print(f\"Current belief (locked): {belief:.2%}\")\n",
            "        \n",
            "        # Score all skills\n",
            "        scores = {}\n",
            "        for skill in skills_available:\n",
            "            efe = score_skill(skill, belief)\n",
            "            scores[skill['name']] = efe\n",
            "            print(f\"  {skill['name']:15s}: EFE = {efe:.2f}\")\n",
            "        \n",
            "        # Choose best skill\n",
            "        chosen_skill_name = min(scores, key=scores.get)\n",
            "        chosen_skill = next(s for s in skills_available if s['name'] == chosen_skill_name)\n",
            "        print(f\"\\n‚Üí Chosen: {chosen_skill_name} (lowest EFE)\")\n",
            "        \n",
            "        # Execute and update belief\n",
            "        if chosen_skill_name == 'peek_door':\n",
            "            new_belief, obs = simulate_belief_update(belief, true_door_state, 'peek_door')\n",
            "            print(f\"  Observation: {obs}\")\n",
            "            print(f\"  Updated belief (locked): {new_belief:.2%}\")\n",
            "            belief = new_belief\n",
            "        \n",
            "        elif chosen_skill_name == 'try_door':\n",
            "            if true_door_state == 'unlocked':\n",
            "                print(f\"  Success! Door was unlocked. ESCAPED!\")\n",
            "                escaped = True\n",
            "            else:\n",
            "                print(f\"  Failed. Door is locked.\")\n",
            "                belief = 0.99  # Now very confident it's locked\n",
            "        \n",
            "        elif chosen_skill_name == 'go_window':\n",
            "            print(f\"  Escaped via window (costly but guaranteed).\")\n",
            "            escaped = True\n",
            "        \n",
            "        history.append({\n",
            "            'step': step,\n",
            "            'belief': belief,\n",
            "            'skill': chosen_skill_name,\n",
            "            'efe': scores[chosen_skill_name]\n",
            "        })\n",
            "    \n",
            "    print(\"\\n\" + \"=\"*70)\n",
            "    if escaped:\n",
            "        print(f\"‚úì ESCAPED in {step} steps!\")\n",
            "    else:\n",
            "        print(f\"‚úó Did not escape within {max_steps} steps.\")\n",
            "    print(\"=\"*70)\n",
            "    \n",
            "    return history\n",
            "\n",
            "# Run simulation\n",
            "print(\"\\nüéÆ Scenario 1: Door is actually UNLOCKED\")\n",
            "history1 = simulate_episode(initial_belief=0.5, true_door_state='unlocked')\n",
            "\n",
            "print(\"\\n\\nüéÆ Scenario 2: Door is actually LOCKED\")\n",
            "history2 = simulate_episode(initial_belief=0.5, true_door_state='locked')\n",
            "\n",
            "display(Markdown(\"\"\"\n",
            "### üéØ Observe the Strategy\n",
            "\n",
            "**Scenario 1 (Unlocked)**:\n",
            "- Agent likely tries door early (belief ~0.5)\n",
            "- Succeeds immediately!\n",
            "- Fast escape\n",
            "\n",
            "**Scenario 2 (Locked)**:\n",
            "- Agent may peek first (uncertain)\n",
            "- Learns door is locked\n",
            "- Switches to window\n",
            "\n",
            "**Key Insight**: Same algorithm, different outcomes based on:\n",
            "1. Initial beliefs\n",
            "2. True world state\n",
            "3. Observations received\n",
            "\n",
            "This is **active inference** adapting to the environment!\n",
            "\"\"\"))"
        ]
    })

    # 3.5 Checkpoint 3
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": ["## 3.5 Checkpoint 3: Understanding Belief Updates"]
    })

    cells.append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "display(Markdown(\"\"\"\n",
            "### ‚úÖ Checkpoint 3\n",
            "\n",
            "**Scenario**:\n",
            "- Prior belief (locked): 60%\n",
            "- Action: peek_door\n",
            "- Observation: obs_door_unlocked\n",
            "- Sensing accuracy: 95%\n",
            "\n",
            "**Question**: What should the posterior belief (locked) be approximately?\n",
            "\n",
            "*Think about it: If you thought 60% locked, but observed \"unlocked\" with 95% accuracy...*\n",
            "\"\"\"))\n",
            "\n",
            "checkpoint3_answer = widgets.FloatSlider(\n",
            "    value=0.5,\n",
            "    min=0,\n",
            "    max=1,\n",
            "    step=0.05,\n",
            "    description='Posterior (locked):',\n",
            "    style={'description_width': 'initial'},\n",
            "    readout_format='.0%'\n",
            ")\n",
            "\n",
            "check3_button = widgets.Button(\n",
            "    description=\"Check Answer\",\n",
            "    button_style='success'\n",
            ")\n",
            "\n",
            "check3_output = widgets.Output()\n",
            "\n",
            "def check_checkpoint3(b):\n",
            "    with check3_output:\n",
            "        clear_output()\n",
            "        \n",
            "        user_answer = checkpoint3_answer.value\n",
            "        \n",
            "        # Correct Bayesian calculation\n",
            "        prior = 0.6\n",
            "        accuracy = 0.95\n",
            "        \n",
            "        # P(Locked | obs_unlocked)\n",
            "        likelihood_locked = 1 - accuracy  # 0.05\n",
            "        likelihood_unlocked = accuracy     # 0.95\n",
            "        \n",
            "        numerator = likelihood_locked * prior\n",
            "        denominator = (likelihood_locked * prior + \n",
            "                      likelihood_unlocked * (1 - prior))\n",
            "        correct = numerator / denominator\n",
            "        \n",
            "        if abs(user_answer - correct) < 0.1:\n",
            "            print(\"‚úì Correct! (or very close)\\n\")\n",
            "            print(f\"Exact answer: {correct:.1%}\")\n",
            "            print(\"\\nExplanation:\")\n",
            "            print(f\"  Prior: {prior:.0%} locked\")\n",
            "            print(f\"  Observed: 'unlocked' (95% accurate sensing)\")\n",
            "            print(f\"  This is STRONG evidence door is unlocked!\")\n",
            "            print(f\"  Posterior: {correct:.1%} locked (confidence flipped!)\")\n",
            "        else:\n",
            "            print(f\"‚úó Not quite. Correct answer: {correct:.1%}\\n\")\n",
            "            print(\"Reasoning:\")\n",
            "            print(f\"  You saw 'unlocked' with 95% accuracy\")\n",
            "            print(f\"  Prior was only 60% locked (moderate)\")\n",
            "            print(f\"  Strong evidence ‚Üí belief should flip!\")\n",
            "            print(f\"  New belief: {correct:.1%} locked = {1-correct:.1%} unlocked\")\n",
            "\n",
            "check3_button.on_click(check_checkpoint3)\n",
            "display(checkpoint3_answer, check3_button, check3_output)"
        ]
    })

    # Part 3 Summary
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "---\n",
            "\n",
            "### üéØ Part 3 Summary\n",
            "\n",
            "**What we learned**:\n",
            "\n",
            "1. ‚úÖ **Database schema** - Node types and relationships in Neo4j\n",
            "2. ‚úÖ **Bayesian inference** - How beliefs update after observations\n",
            "3. ‚úÖ **Belief dynamics** - Prior ‚Üí Observation ‚Üí Posterior\n",
            "4. ‚úÖ **Procedural memory** - Learning context ‚Üí skill patterns\n",
            "5. ‚úÖ **Episode simulation** - Complete agent execution from start to escape\n",
            "6. ‚úÖ **Adaptive behavior** - Same algorithm, different strategies based on observations\n",
            "\n",
            "### üîó The Bridge\n",
            "\n",
            "We've now seen:\n",
            "- **Part 1**: The problem (locked door)\n",
            "- **Part 2**: The math (EFE formula)\n",
            "- **Part 3**: The execution (beliefs update, agent learns)\n",
            "\n",
            "**Next**: Can we UNDERSTAND the agent's strategy at a glance?\n",
            "\n",
            "‚Üí **Part 4: The Silver Gauge** (geometric diagnostics!)\n",
            "\n",
            "We need interpretable metrics that don't change behavior...\n",
            "\n",
            "Enter: Pythagorean means! üìê"
        ]
    })

    return cells


def insert_part3_into_notebook(notebook_path):
    """Insert Part 3 between Parts 2 and 4"""
    with open(notebook_path, 'r') as f:
        nb = json.load(f)

    # Find insertion point (after Part 2, before Part 4)
    insert_idx = None
    for i, cell in enumerate(nb['cells']):
        if cell['cell_type'] == 'markdown':
            content = ''.join(cell['source'])
            if 'PART 4:' in content or '# PART 4' in content:
                insert_idx = i
                break

    if insert_idx is None:
        print("‚ö† Could not find Part 4 to insert before. Appending to end.")
        insert_idx = len(nb['cells'])

    # Insert Part 3 cells
    part3_cells = create_part3_cells()
    nb['cells'] = nb['cells'][:insert_idx] + part3_cells + nb['cells'][insert_idx:]

    with open(notebook_path, 'w') as f:
        json.dump(nb, f, indent=1)

    print(f"‚úì Inserted {len(part3_cells)} cells for Part 3 at position {insert_idx}")


if __name__ == "__main__":
    notebook_path = "/home/juancho/macgyver_mud/MacGyverMUD_DeepDive.ipynb"

    print("Creating Part 3: Belief Updates & Procedural Memory...")
    print("This is THE MISSING BRIDGE between Parts 2 and 4!")

    insert_part3_into_notebook(notebook_path)

    print("\\n‚úì Part 3 added successfully!")
    print("  - Database schema visualization")
    print("  - Bayesian belief updates (interactive!)")
    print("  - Procedural memory network")
    print("  - Full episode simulation")
    print("  - Checkpoint 3")
